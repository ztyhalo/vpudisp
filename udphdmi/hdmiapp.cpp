#include "hdmiapp.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>




sem_t                mgsem;

#define TTL 64
#define BUFF_SIZE 1025
uint8_t rec_num = 0;


extern char  imagedata[300][1020];
uint   imageleng;
uint    imagetail;

HDMI_CLIENT::HDMI_CLIENT()
{
    hdmi_c_ttl = 0x924;
    hdmi_heart.udp_class_init(48689, "192.168.168.55");
    hdmi_heart.udp_broad_send_init(64);
    hdmi_heart.bind_port(48689);
    hdmi_image.udp_class_init(2068);
    hdmi_image.udp_mul_read_init("226.2.2.2");
}



void HDMI_CLIENT::hdmi_heart_ack(void)
{
    char send_buf[512] = {
            0x54, 0x46, 0x36, 0x7a, 0x60, 0x02, 0x00, 0x00,
            0x69, 0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x26,
            0x1f, 0x1f, 0x00, 0x03, 0x36, 0x96, 0x87, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    send_buf[8] = hdmi_c_ttl;
    send_buf[9] = hdmi_c_ttl >> 8;
    hdmi_heart.udp_send(send_buf, 512);
    hdmi_c_ttl++;

}

void * hdmi_heart_pthread(void * arg)
{
    HDMI_CLIENT * client = (HDMI_CLIENT *)arg;
    char rev_buf[512];

    memset(rev_buf, 0x00, sizeof(rev_buf));

    struct sockaddr_in recaddr;
    memset(&recaddr, 0x00, sizeof(recaddr));

    while(1)
    {
        if(client->hdmi_heart.udp_read(rev_buf, 512, &recaddr))
        {
            if(inet_addr("192.168.168.56") == recaddr.sin_addr.s_addr)
            {
                printf("local\n");
            }
            else
            {
//               printf("else %s\n", inet_ntoa(recaddr.sin_addr));
               client->hdmi_heart_ack();
            }
        }

    }
    return NULL;
}


void * hdmi_image_progress(void * arg)
{

    //每次读到的字符串长度
    int str_len;
    int start_mark = 0;
    int ttl_error = 0;
    int end_leng = 0;


    //用于保存数据的字符缓冲
    uint8_t  buff[BUFF_SIZE];


    FILE * fp;
    HDMI_CLIENT * client = (HDMI_CLIENT *)arg;

//    if((access("jpegtest",F_OK))==-1)
//        {
//            if(creat("jpegtest",0755)<0){
//                    qDebug("create file failure!\n");
//                    return NULL;
//            }
//        }

//     fp = ::fopen("jpegtest", "rb+");
//     if(fp == NULL)
//          qDebug("file open error!");

    memset(buff, 0x00, sizeof(buff));
    memset(imagedata, 0x00, sizeof(imagedata));
    printf("image start!");
    while(1){
        //接收发送来的消息，因为之前已经将socket注册到组播中
        str_len= client->hdmi_image.udp_read(buff,1024);
        if(str_len<0){
            printf("read error!");
            break;
        }
//        qDebug("start_mark %d buff[3] %d", start_mark, buff[3]);
        if(start_mark == 0 && buff[3] == 0)
        {
            start_mark = 1;
            rec_num = 1;
            ttl_error = 0;
//            if(-1 == (fseek(fp, 0, SEEK_SET)))
//                qDebug("seek error\n");
//            qDebug("write 1");
//            ::fwrite(buff+4, 1, str_len-4, fp);
            memcpy(imagedata[0], buff+4,  str_len-4);


        }
        else if(start_mark)
        {
//            qDebug("ttl %d!\n",  buff[3]);
            if(rec_num != buff[3])
            {
                printf("ttl error %d %d!\n", rec_num, buff[3]);
                ttl_error = 1;
            }
            rec_num++;

//            if(-1 == (fseek(fp, buff[3] * (1024-4), SEEK_SET)))
//                qDebug("seek error\n");

//            if(buff[2] != 0)
//            {
//                for(int i = 0; i < str_len; i++)
//                {
//                    if(buff[4+i] == 0xff && buff[4+i+1] == 0xd9)
//                    {
//                        fwrite(buff+4+i, 1, 2, fp);
//                        break;
//                    }
//                    fwrite(buff+4+i, 1, 1, fp);
//                }
//            }
//            else
            {
//                fwrite(buff+4, 1, str_len -4, fp);
                memcpy(imagedata[buff[3]], buff+4,  str_len-4);
            }


            if(buff[2] != 0)
            {

                start_mark = 0;
                rec_num = 0;
                if(ttl_error == 0)
                {
                    for( end_leng = 0; end_leng < str_len; end_leng++)
                    {
                        if(buff[4+end_leng] == 0xff && buff[4+end_leng+1] == 0xd9)
                        {
                            break;
                        }
                    }

//                    if(-1 == (fseek(fp, 0, SEEK_SET)))
//                        qDebug("seek error\n");
//                    fwrite(imagedata, 1020, buff[3], fp);
//                    fwrite(imagedata[buff[3]], 1, end_leng+2, fp);
//                    imageleng = 1020 *buff[3]  + end_leng +2;
//                    imageleng = 1020 *(buff[3]+ 1);
                    imageleng = buff[3];
                    imagetail = end_leng +2;
//                    client->hdmi_show();
                    client->hdmi_image.close_fd();
                    sem_wait(&mgsem);
                    client->hdmi_image.udp_class_init(2068);
                    client->hdmi_image.udp_mul_read_init("226.2.2.2");
                }
            }

        }
        else
            rec_num = 0;
    }

return 0;
}

void error_handling(char * message){
    fputs(message,stderr);
    fputc('\n',stderr);
    return;
}

